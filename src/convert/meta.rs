use std::collections::HashMap;

#[derive(Default)]
pub(super) struct DirMetadata {
    pub(super) ignores: Vec<u8>,
    pub(super) global_ignores: Vec<u8>,
    pub(super) mergeinfo: Vec<u8>,
    pub(super) mergeinfo_integrated: Vec<u8>,
}

impl DirMetadata {
    pub(super) fn from_props(
        props: &HashMap<Vec<u8>, Option<Vec<u8>>>,
        prev_meta: Option<Self>,
    ) -> Self {
        let mut new_meta = prev_meta.unwrap_or_default();

        if let Some(prop_value) = props.get(b"svn:ignore".as_slice()) {
            new_meta.ignores.clear();
            if let Some(prop_value) = prop_value {
                new_meta.ignores.extend(prop_value);
            }
        }

        if let Some(prop_value) = props.get(b"svn:global-ignores".as_slice()) {
            new_meta.global_ignores.clear();
            if let Some(prop_value) = prop_value {
                new_meta.global_ignores.extend(prop_value);
            }
        }

        // generated by `svn merge`
        if let Some(prop_value) = props.get(b"svn:mergeinfo".as_slice()) {
            new_meta.mergeinfo.clear();
            if let Some(prop_value) = prop_value {
                new_meta.mergeinfo.extend(prop_value);
            }
        }

        // generated by `svnmerge.py`
        if let Some(prop_value) = props.get(b"svnmerge-integrated".as_slice()) {
            new_meta.mergeinfo_integrated.clear();
            if let Some(prop_value) = prop_value {
                new_meta.mergeinfo_integrated.extend(prop_value);
            }
        }

        new_meta
    }

    pub(super) fn serialize(&self) -> Vec<u8> {
        let mut out = Vec::new();
        Self::serialize_bytes(&self.ignores, &mut out);
        Self::serialize_bytes(&self.global_ignores, &mut out);
        Self::serialize_bytes(&self.mergeinfo, &mut out);
        Self::serialize_bytes(&self.mergeinfo_integrated, &mut out);
        out
    }

    pub(super) fn deserialize(raw: &[u8]) -> Option<Self> {
        let mut src = raw;

        let ignores = Self::deserialize_bytes(&mut src)?;
        let global_ignores = Self::deserialize_bytes(&mut src)?;
        let mergeinfo = Self::deserialize_bytes(&mut src)?;
        let mergeinfo_integrated = Self::deserialize_bytes(&mut src)?;

        if !src.is_empty() {
            return None;
        }

        Some(Self {
            ignores,
            global_ignores,
            mergeinfo,
            mergeinfo_integrated,
        })
    }

    fn serialize_bytes(bytes: &[u8], dst: &mut Vec<u8>) {
        dst.extend(bytes.len().to_ne_bytes());
        dst.extend(bytes);
    }

    fn deserialize_bytes(src: &mut &[u8]) -> Option<Vec<u8>> {
        let raw_len;
        (raw_len, *src) = src.split_first_chunk()?;
        let len = usize::from_ne_bytes(*raw_len);

        if src.len() < len {
            return None;
        }
        let data;
        (data, *src) = src.split_at(len);

        Some(data.to_vec())
    }
}

pub(super) fn svnignore_to_gitignore(svnignore: &[u8], is_global: bool) -> Vec<u8> {
    let mut gitignore = Vec::new();
    for line in svnignore.split(|&c| c == b'\n') {
        let line = line.strip_suffix(b"\r").unwrap_or(line);
        if line.is_empty() {
            continue;
        }
        if line == b"CVS" {
            // likely some leftover we don't need
            continue;
        }

        if is_global {
            gitignore.extend(line);
            gitignore.push(b'\n');
        } else {
            gitignore.push(b'/');
            gitignore.extend(line);
            gitignore.push(b'\n');
        }
    }

    gitignore
}

pub(super) fn parse_mergeinfo(raw1: &[u8], raw2: &[u8]) -> HashMap<Vec<u8>, Vec<(u32, u32, bool)>> {
    let mut mergeinfo = HashMap::<Vec<u8>, Vec<(u32, u32, bool)>>::new();
    for raw in [raw1, raw2] {
        for line in raw.split(|&c| c == b'\n') {
            let line = line.strip_suffix(b"\r").unwrap_or(line);
            if line.is_empty() {
                continue;
            }

            if let Some((path, mut rev_ranges)) = parse_mergeinfo_line(line) {
                mergeinfo.entry(path).or_default().append(&mut rev_ranges);
            } else {
                tracing::warn!("invalid mergeinfo line: \"{}\"", line.escape_ascii());
            }
        }
    }

    mergeinfo
}

fn parse_mergeinfo_line(line: &[u8]) -> Option<(Vec<u8>, Vec<(u32, u32, bool)>)> {
    let colon_pos = line.iter().rposition(|&c| c == b':')?;
    let path = line[..colon_pos].strip_prefix(b"/")?;

    let mut rev_ranges = Vec::new();
    for rev_range in line[(colon_pos + 1)..].split(|&c| c == b',') {
        let (rev_range, non_inheritable) = if let Some(rev_range) = rev_range.strip_suffix(b"*") {
            (rev_range, true)
        } else {
            (rev_range, false)
        };

        if let Some(dash_pos) = rev_range.iter().position(|&c| c == b'-') {
            // Range
            let start_rev_no = std::str::from_utf8(&rev_range[..dash_pos])
                .ok()
                .and_then(|s| s.parse::<u32>().ok())?;
            let end_rev_no = std::str::from_utf8(&rev_range[(dash_pos + 1)..])
                .ok()
                .and_then(|s| s.parse::<u32>().ok())?;
            if start_rev_no > end_rev_no {
                tracing::warn!("invalid mergeinfo range: {start_rev_no}-{end_rev_no}");
            } else {
                rev_ranges.push((start_rev_no, end_rev_no, non_inheritable));
            }
        } else {
            // Single
            let rev_no = std::str::from_utf8(rev_range)
                .ok()
                .and_then(|s| s.parse::<u32>().ok())?;
            rev_ranges.push((rev_no, rev_no, non_inheritable));
        }
    }

    Some((path.to_vec(), rev_ranges))
}
