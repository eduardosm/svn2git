use crate::FHashMap;

use super::bin_ser_de::{self, DeserializeError};

#[derive(Clone, Default)]
pub(super) struct DirMetadata {
    pub(super) ignore: Vec<u8>,
    pub(super) global_ignores: Vec<u8>,
    pub(super) mergeinfo: Vec<u8>,
    pub(super) svnmerge_integrated: Vec<u8>,
}

impl DirMetadata {
    pub(super) fn from_props(
        props: &FHashMap<Vec<u8>, Option<Vec<u8>>>,
        prev_meta: Option<Self>,
    ) -> Self {
        let mut new_meta = prev_meta.unwrap_or_default();

        if let Some(prop_value) = props.get(b"svn:ignore".as_slice()) {
            new_meta.ignore.clear();
            if let Some(prop_value) = prop_value {
                new_meta.ignore.extend(prop_value);
            }
        }

        if let Some(prop_value) = props.get(b"svn:global-ignores".as_slice()) {
            new_meta.global_ignores.clear();
            if let Some(prop_value) = prop_value {
                new_meta.global_ignores.extend(prop_value);
            }
        }

        // generated by `svn merge`
        if let Some(prop_value) = props.get(b"svn:mergeinfo".as_slice()) {
            new_meta.mergeinfo.clear();
            if let Some(prop_value) = prop_value {
                new_meta.mergeinfo.extend(prop_value);
            }
        }

        // generated by `svnmerge.py`
        if let Some(prop_value) = props.get(b"svnmerge-integrated".as_slice()) {
            new_meta.svnmerge_integrated.clear();
            if let Some(prop_value) = prop_value {
                new_meta.svnmerge_integrated.extend(prop_value);
            }
        }

        new_meta
    }

    pub(super) fn serialize(&self) -> Vec<u8> {
        let mut out = Vec::new();
        self.serialize_into(&mut out);
        out
    }

    pub(super) fn serialize_into(&self, out: &mut Vec<u8>) {
        bin_ser_de::serialize_byte_slice_into(&self.ignore, out);
        bin_ser_de::serialize_byte_slice_into(&self.global_ignores, out);
        bin_ser_de::serialize_byte_slice_into(&self.mergeinfo, out);
        bin_ser_de::serialize_byte_slice_into(&self.svnmerge_integrated, out);
    }

    pub(super) fn deserialize(mut src: &[u8]) -> Result<Self, DeserializeError> {
        let r = Self::deserialize_from(&mut src)?;
        if !src.is_empty() {
            return Err(DeserializeError);
        }
        Ok(r)
    }

    pub(super) fn deserialize_from(src: &mut &[u8]) -> Result<Self, DeserializeError> {
        let ignore = bin_ser_de::deserialize_byte_slice_from(src)?;
        let global_ignores = bin_ser_de::deserialize_byte_slice_from(src)?;
        let mergeinfo = bin_ser_de::deserialize_byte_slice_from(src)?;
        let mergeinfo_integrated = bin_ser_de::deserialize_byte_slice_from(src)?;

        Ok(Self {
            ignore,
            global_ignores,
            mergeinfo,
            svnmerge_integrated: mergeinfo_integrated,
        })
    }
}

pub(super) fn svnignore_to_gitignore(svnignore: &[u8], is_global: bool) -> Vec<u8> {
    let mut gitignore = Vec::new();
    for line in svnignore.split(|&c| c == b'\n') {
        let line = line.strip_suffix(b"\r").unwrap_or(line);
        if line.is_empty() {
            continue;
        }
        if line == b"CVS" {
            // likely some leftover we don't need
            continue;
        }

        if is_global {
            gitignore.extend(line);
            gitignore.push(b'\n');
        } else {
            gitignore.push(b'/');
            gitignore.extend(line);
            gitignore.push(b'\n');
        }
    }

    gitignore
}

pub(super) fn parse_mergeinfo(
    raw1: &[u8],
    raw2: &[u8],
) -> FHashMap<Vec<u8>, Vec<(u32, u32, bool)>> {
    let mut mergeinfo = FHashMap::<Vec<u8>, Vec<(u32, u32, bool)>>::default();
    for raw in [raw1, raw2] {
        for line in raw.split(|&c| c == b'\n') {
            let line = line.strip_suffix(b"\r").unwrap_or(line);
            if line.is_empty() {
                continue;
            }

            if let Some((path, mut rev_ranges)) = parse_mergeinfo_line(line) {
                mergeinfo.entry(path).or_default().append(&mut rev_ranges);
            } else {
                tracing::warn!("invalid mergeinfo line: \"{}\"", line.escape_ascii());
            }
        }
    }

    mergeinfo
}

fn parse_mergeinfo_line(line: &[u8]) -> Option<(Vec<u8>, Vec<(u32, u32, bool)>)> {
    let colon_pos = line.iter().rposition(|&c| c == b':')?;
    let path = line[..colon_pos].strip_prefix(b"/")?;

    let mut rev_ranges = Vec::new();
    for rev_range in line[(colon_pos + 1)..].split(|&c| c == b',') {
        let (rev_range, non_inheritable) = if let Some(rev_range) = rev_range.strip_suffix(b"*") {
            (rev_range, true)
        } else {
            (rev_range, false)
        };

        if let Some(dash_pos) = rev_range.iter().position(|&c| c == b'-') {
            // Range
            let start_rev_no = std::str::from_utf8(&rev_range[..dash_pos])
                .ok()
                .and_then(|s| s.parse::<u32>().ok())?;
            let end_rev_no = std::str::from_utf8(&rev_range[(dash_pos + 1)..])
                .ok()
                .and_then(|s| s.parse::<u32>().ok())?;
            if start_rev_no > end_rev_no {
                tracing::warn!("invalid mergeinfo range: {start_rev_no}-{end_rev_no}");
            } else {
                rev_ranges.push((start_rev_no, end_rev_no, non_inheritable));
            }
        } else {
            // Single
            let rev_no = std::str::from_utf8(rev_range)
                .ok()
                .and_then(|s| s.parse::<u32>().ok())?;
            rev_ranges.push((rev_no, rev_no, non_inheritable));
        }
    }

    Some((path.to_vec(), rev_ranges))
}
